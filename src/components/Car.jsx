/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 car.glb
*/

import React, { useRef, useEffect, useLayoutEffect, useState, useMemo } from 'react';
import { SkeletonUtils } from 'three-stdlib';
import { useFrame, useGraph } from '@react-three/fiber';
import { useGLTF } from '@react-three/drei';
import { useStore } from '../hooks/useStore';
import * as THREE from 'three';

function Line({ start, end }) {
  const ref = useRef();
  useLayoutEffect(() => {
    ref.current.geometry.setFromPoints([start, end].map((point) => new THREE.Vector3(...point)));
  }, [start, end]);
  return (
    <line ref={ref}>
      <bufferGeometry />
      <lineBasicMaterial color="hotpink" linewidth="2.0" />
    </line>
  );
}

export function Car({ entity }) {
  const group = useRef();
  const meshRef = useRef();
  const [debug] = useStore((state) => [state.debug]);
  const [lines, setLines] = useState([]);

  const { scene, materials } = useGLTF('/Models/newModels/Vehicles/car.glb');
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes } = useGraph(clone);

  const setTemplines = (entity) => {
    let templines = [];
    entity.graph.GetVertices().forEach((vertex) => {
      let vertextObj = entity.graph.GetVertexByKey(vertex);
      let cv = entity.graph.GetConnectedVerticesTo(vertex);

      cv.forEach((vertexNeighbour) => {
        const points = [];
        points.push(
          new THREE.Vector3(vertextObj.vertex.position.x, 0.25, vertextObj.vertex.position.z),
        );
        points.push(
          new THREE.Vector3(
            vertexNeighbour.vertex.position.x,
            0.25,
            vertexNeighbour.vertex.position.z,
          ),
        );
        templines.push(points);
      });
    });
    return templines;
  };

  useEffect(() => {
    let templines = setTemplines(entity);
    setLines(templines);
  }, []);

  useFrame((state, delta) => {
    meshRef.current.position.x = entity.position.x;
    meshRef.current.position.z = entity.position.z;
    meshRef.current.position.y = entity.position.y;
    meshRef.current.quaternion.setFromRotationMatrix(entity.direction);
    if (entity.updateGraph === true) {
      let templines = setTemplines(entity);
      setLines(templines);
      entity.updateGraph = false;
    }
  });
  return (
    <>
      <mesh ref={meshRef} castShadow position={[entity.position.x, 0.025, entity.position.z]}>
        <group ref={group} dispose={null} scale={(0.05, 0.05, 0.05)}>
          <group position={[0, -0.04, 0]}>
            <mesh geometry={nodes.Cube.geometry} material={materials.Base} />
            <mesh geometry={nodes.Cube_1.geometry} material={materials.Glass} />
            <mesh geometry={nodes.Cube_2.geometry} material={materials.Headlight} />
            <mesh geometry={nodes.Cube_3.geometry} material={materials.Silver} />
            <mesh geometry={nodes.Cube_4.geometry} material={materials.Black} />
            <mesh geometry={nodes.Cube_5.geometry} material={materials.LicensePlate} />
            <mesh geometry={nodes.Cube_6.geometry} material={materials.TailLight} />
          </group>
          <group position={[0, -0.026, 0]}>
            <mesh geometry={nodes.Wheels_1.geometry} material={materials.Black} />
            <mesh geometry={nodes.Wheels_2.geometry} material={materials.Silver} />
          </group>
        </group>
      </mesh>
      {debug &&
        lines.map((line, index) => {
          return (
            <Line
              start={[line[0].x, line[0].y, line[0].z]}
              end={[line[1].x, line[1].y, line[1].z]}
              key={index}
            />
          );
        })}
    </>
  );
}

useGLTF.preload('/Models/newModels/Vehicles/car.glb');
export default Car;
